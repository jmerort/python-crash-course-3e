Appendix D notes

@jmerort

Oct 2025
___

# AD - Using Git for version control
To **install Git**, you can check for an installer in https://git-scm.com or run `sudo apt install git` if you're on Linux. 

To check if it's already installed run `git --version` or `git -v` in the command line.

Before doing anything with Git, you must **configure** it, by providing a username and an email address, though it can be a fake one. 
```
git config --global user.name "name"
git config --global user.email "mail@example.com"
```
To give a name (usually we use "main") to the default branch of each project use:
```
git config --global init.defaultBranch main
```

To **start a Git project**, we first create a folder in which the files whose changes we want to track will be stored. There will be some files that we don't want to track, such as those automatically generated by IDE's, compilers, the Python interpreter and so forth. To tell Git not to track them we include their names in a file falled `.gitignore`.
For example, a Python project will have an ignore file that includes:
```
__pycache__/
```
To have the automatically created files in that directory **ignored**. (On MAC one should also add a `.DS_Store`, to ignore these information files.)

Files whose names begin with dots are sometimes hidden; you can change this in the file explorer settings.

To **initialize** a Git repository, go to its folder in the command line and run
```
git init
```
This will create a new hidden directory named `.git`, where the project management files will be located. You don't need to do anything with it. 

To check the project **status** run 
```
git status
```
A branch is a version of the project. 

To **add** the current directory files to the project (those not already tracked), run
```
git add .
```
After making changes to the tracked files, we can make a **commit** and add a message with the `-m` argument. A commit is a snapshot of the project at one point in time.
```
git commit -m "Started the project!"
```
Now the status of the project should tell us we have a clean working tree. If not, we probably forgot to do something before making the commit. 

To check the **log** of all commits made to a project, use:
```
git log
```
this will print, among other info, the 40-character reference ID of each commit. It records who made the commit, when it was made, and the message recorded. To see only the most important info, use:
```
git log --pretty=oneline
```

When we **change the file further**, we will commit the changes using:
```
git commit -am "New changes"
```
The `-a` flag tells Git to add all modified files in the repo to the current commit. If you create new files and want to track them too, run `git add .` again.

To **abandon a change**, going back to the previous working state, before we have commited the "bad" version, we use:
```
git restore .
```
This restores our program to the last commited version. It can be used with specific files or with all files (if we use `.`). This allows us to make as many changes as we want to a file and, if they don't work, we just discard them automatically.

You can **revisit a commit** using the checkout command and giging it the first six characters of the reference ID (see log):
```
git checkout 32c312
```
You will then leave the main branch and enter into a **detached HEAD** state, the head being the commit you are checking out. In this state you can see the files from a previous commit and run it. For beginner Git users, it's best to not modify anything here.

To go back to the main branch, use:
```
git switch -
```
To **go back permanently to a previous commit**, first check the satus to make sure you are on main and then run `git reset` with the ID of the commit you want to go back to:
```
git reset --hard cea13d
```

Finally, to **delete the Git history** of a project, delete the `.git/` directory using
```
rm -rf .git/
```
This will not delete the current project files, but you will lose all previous commit info and the ability to go back to previous versions. After deleting the history, you can start tracking changes again by following the same steps as before.
